
#' @title Safe Scale
#'
#' @description Z-score scales matrix
#' 
#' @param m Matrix input
#' 
#' @return Scaled matrix object
#'

safe_scale = function(m){
  stats::na.omit(t(scale(t(m))))
}

#' @title Generate Gene List for Enrichment
#' 
#' @description
#' Using the linear model fit, coeficient selection, and enrichment type, output a ranked
#' gene list to be used for enrichment.
#' 
#' @param fit Linear model fit output by limma package
#' @param coef string containing contrast to use as coefficient for top table
#' @param gmt string input - GMT file input name
#'
#' @return named list geneList object
#'

# geneList <- calculateGeneList(fit, coef = "Glucose-NoGlucose", enrichment_type = "PKSEA")
# print(head(geneList))

calculateGeneList <- function(fit,
                              coef,
                              gmt){
  
  # GENERATE TOP TABLE
  top_sum <- limma::topTable(fit, adjust.method = "BH", n = Inf, sort.by = 'p', coef = coef);
  
  
  # RANKED LIST IF PROTEINGROUP DATA
  if (!grepl("PHOSPHO", gmt)){
    top_sum$fcSign = sign(top_sum$logFC)
    top_sum$logP = -log10(top_sum$P.Value)
    top_sum$metric = top_sum$logP / top_sum$fcSign
    
    ranked <- top_sum[,c("Gene", "metric")]
    
  # RANKED LIST IF PHOSPHOSITE DATA 
  } else {
    top_sum$fcSign = sign(top_sum$logFC)
    top_sum$logP = -log10(top_sum$P.Value)
    top_sum$metric = top_sum$logP / top_sum$fcSign
    
    if ("Position" %in% colnames(top_sum)){ # MaxQuant
      ranked <- cbind(paste0(top_sum[,"Protein"], ";", top_sum[,"Amino.acid"], top_sum[,"Position"]), top_sum[,"metric"])
    } else if ("Index" %in% colnames(top_sum)){ # FragPipe
      ranked <- cbind(paste0(top_sum[,"Protein"], ";", gsub(".*_", "", top_sum[,"Index"])), top_sum[,"metric"])
    }
    colnames(ranked) <- c("ID", "rank")
    
  }
  
  # MAKE GENE LIST
  ranked <- ranked[ranked[,1]!="", ]
  ranked <- ranked[order(abs(as.numeric(ranked[,2])), decreasing = TRUE),]
  ranked <- ranked[!duplicated(ranked[,1]),]
  
  geneList <- as.numeric(ranked[,2])
  names(geneList) <- as.character(ranked[,1])
  geneList <- sort(geneList, decreasing = TRUE)
  
  print(str(geneList))
  return(geneList)
  
}

#' @title clusterProfiler Enrichment
#'
#' @description
#' Using geneList and GMT file, perform enrichment on data.
#' 
#' @param geneList  geneList named list as generated by calculateGeneList function above.
#' @param gmt The name of the GMT file to be referenced as a database for enrichment analysis.
#' @param enrichment Whether to do ranked or unranked enrichment analysis (effectively GSEA or ORA).
#' @param pval_cutoff What the adjusted p-value cutoff should be in enrichment analysis.
#'
#' @return clusterProfiler enriched object

clusterProfilerEnrichment <- function(geneList,
                                      gmt = "",
                                      enrichment = "",
                                      pval_cutoff = 1){
  
  # GENERATE GMT REFERENCES
  GMT_file <- list.files("./GMTs", pattern = gmt)
  my_geneset = readr::read_delim(paste0("./GMTs/", GMT_file))

  
  my_geneset = dplyr::mutate(my_geneset, term = pathway)
  my_geneset$feature_ids <- gsub("\\-.*","",my_geneset$feature_ids)
  term2features = my_geneset %>% dplyr::select(term, feature_ids)
  term2pathway = my_geneset %>% dplyr::select(term, pathway)
  rm(my_geneset)
  
  # assign("universe", term2features$feature_ids, envir = .GlobalEnv)
  
  enriched <- "NONE"
  
  try({
    # UNRANKED ENRICHMENT
    if (enrichment == 'unranked'){
      enriched <- clusterProfiler::enricher(gene = names(geneList),
                                            universe = term2features$feature_ids,
                                            pAdjustMethod = "fdr",
                                            pvalueCutoff = pval_cutoff,
                                            minGSSize = 2,
                                            TERM2GENE = term2features,
                                            TERM2NAME = term2pathway )
      
      # RANKED ENRICHMENT
    } else if (enrichment == 'ranked'){
        enriched <- clusterProfiler::GSEA(gene = geneList,
                                          pAdjustMethod = "fdr",
                                          pvalueCutoff = pval_cutoff,
                                          minGSSize = 2,
                                          eps = 0,
                                          TERM2GENE = term2features,
                                          TERM2NAME = term2pathway)
      
    }
  })
  
  return(enriched)
}

#' @title clusterProfiler Enrichment Results Table
#'
#' @description
#' Generate a table from the enrichment results.
#' 
#' @param enriched The enriched result object from clusterProfilerEnrichment function above.
#' @param enrichment Enrichment type, either ranked or unranked.
#'

# table <- enrichedTable(enriched_Phospho, enrichment = "unranked")
enrichedTable <- function(enriched, 
                          enrichment){
  
  if (is.character(enriched)){
    return("There are no enriched pathways in the dataset for the selected database and p-value cutoff.")
  }
  
  # GENERATE TABLE
  if (nrow(enriched@result) == 0){
    enriched_table <- NULL
    
  } else {
    if (enrichment == 'unranked'){
      enriched_table = enriched@result %>%
        as.data.frame() %>%
        tibble::remove_rownames() %>%
        dplyr::select(Description, pvalue, p.adjust, qvalue, Count, GeneRatio,                                                                                                               intersection = geneID) %>%
        dplyr::mutate(intersection = stringr::str_replace_all(intersection, "/", ", "))
      
    } else if (enrichment == 'ranked') {
      enriched_table = enriched@result %>%
        as.data.frame() %>%
        tibble::remove_rownames() %>%
        dplyr::select(Description, pvalue, p.adjust, qvalue, setSize, NES, intersection = core_enrichment) %>%
        dplyr::mutate(intersection = stringr::str_replace_all(intersection, "/", ", "))
    }
  }
  
  return(enriched_table)
}

#' @title Retrieve KEGG ID
#'
#' @description
#' For KEGG based database enrichment, retrieve the KEGG ID using the name/description of the pathway,
#' which is then used for the KEGG pathway overview visualization.
#' 
#' @param gmt Name of the KEGG GMT file used for enrichment.
#' @param KEGG_pathway String name of the enriched KEGG pathway.
#' 
#' @return String KEGG ID of pathway
#'

getKEGGID <- function(gmt,
                      KEGG_pathway) {
  
  # gmt <- "HUMAN"
  # KEGG_pathway <- "Spliceosome"
  if (grep("HUMAN", gmt)) {
    KEGG_species <- "hsa"
    org <- org.Hs.eg.db::org.Hs.eg.db
  } else if (grep("MOUSE", gmt)) {
    KEGG_species <- "mmu"
    org <- org.Mm.eg.db::org.Mm.eg.db
  } else if (grep("YEAST", gmt)) {
    KEGG_species <- "sce"
    org <- org.Sc.sgd.db::org.Sc.sgd.db
  } else if (grep("ZEBRAFISH", gmt)) {
    KEGG_species <- "dre"
    org <- org.Dr.eg.db::org.Dr.eg.db
  } else if (grep("CELEGANS", gmt)) {
    KEGG_species <- "cel"
    org <- org.Ce.eg.db::org.Ce.eg.db
  } else if (grep("FRUITFLY", gmt)) {
    KEGG_species <- "dme"
    org <- org.Dm.eg.db::org.Dm.eg.db
  } else if (grep("RAT", gmt)) {
    KEGG_species <- "rno"
    org <- org.Rn.eg.db::org.Rn.eg.db
  }
  
  path_eg  <- KEGGREST::keggLink("pathway", KEGG_species) %>% 
    tibble(pathway = ., eg = sub(paste(KEGG_species, ":", sep = ""), "", names(.)))
  
  kegg_anno <- path_eg %>%
    mutate(
      symbol = AnnotationDbi::mapIds(org, eg, "SYMBOL", "ENTREZID"),
      ensembl = AnnotationDbi::mapIds(org, eg, "ENSEMBL", "ENTREZID")
    )
  
  pathways <- KEGGREST::keggList("pathway", KEGG_species) %>% 
    tibble(pathway = names(.), description = .)
  
  pathways$description <- sub("\\ -.*", "", pathways$description)
  pw <- pathways[which(pathways$description == KEGG_pathway),]$pathway
  
  return(pw)
}
  
#' @title clusterProfiler Enrichment Plots
#'
#' @description
#' Generate an enrichment visualization plot using the enriched object from clusterProfilerEnrichment function above.
#' 
#' @param enriched Enrichment object output by clusterProfilerEnrichment function
#' @param enrichment either ranked or unranked
#' @param gmt GMT file name used for enrichment
#' @param geneList geneList named list generated by calculateGeneList function
#' @param contrast string contrast coeficient used for generating topTable in calculateGeneList
#' @param plottype type of plot to generate i.e. dot, tree, cnet, etc.
#' @param KEGGID for KEGG plots, the KEGG ID generated by getKEGGID function
#' @param dotplot_categories number of top pathways to include in the dot plot
#' @param dotplot_title customization of dot plot title
#' @param cnetplot_categories number of top pathways to include in the cnet plot
#' @param cnetplot_layout string that specifies layout, i.e. kk, etc.
#' @param cnetplot_label which nodes to label in the cnet plot, category, gene, all, or none
#' @param cnet_title customization of cnet plot title
#' @param emap_categories number of top pathways to include in the emap plot
#' @param emap_title customization of emap title
#' @param emap_category_label size of the labels im th emap plot
#' @param upset_categories number of top pathways to include in the upset plot
#' @param upsetplot_title customization of upset title
#' @param tree_categories number of top pathways to include in the tree plot
#' @param tree_clusters how many groups to cluster pathways into
#' @param treeplot_title customization of tree diagram title
#' @param heatmap_color color to make heatmap
#' @param heatmap_title customization of heatmap title
#' 
#' @return plot object output
#'

enrichedPlots <- function(enriched,
                          enrichment = "",
                          gmt = "",
                          geneList,
                          contrast = "",
                          plottype = "dot",
                          KEGGID,
                          dotplot_categories = 15,
                          dotplot_title = "",
                          cnetplot_categories = 5,
                          cnetplot_layout = "kk",
                          cnetplot_label = "category",
                          cnet_title = "",
                          emap_categories = 30,
                          emap_title = "",
                          emap_category_label = 1,
                          upset_categories = 10,
                          upsetplot_title = "",
                          tree_categories = 30,
                          tree_clusters = 5,
                          treeplot_title = "",
                          heatmap_color,
                          heatmap_title = "") {
  
  if (is.character(enriched)){
    return("There are no enriched pathways in the dataset for the selected database and p-value cutoff.")
  }
  
  enriched_pairwise <- enrichplot::pairwise_termsim(enriched)
  
  # GO PLOT
  if (plottype == "GO"){
    plot <- enrichplot::goplot(enriched)
    
  # KEGG PLOT
  } else if (plottype == "KEGG") {
    if (grep("HUMAN", gmt)) {
      KEGG_species <- "hsa"
    } else if (grep("MOUSE", gmt)) {
      KEGG_species <- "mmu"
    } else if (grep("YEAST", gmt)) {
      KEGG_species <- "sce"
    } else if (grep("ZEBRAFISH", gmt)) {
      KEGG_species <- "dre"
    } else if (grep("CELEGANS", gmt)) {
      KEGG_species <- "cel"
    } else if (grep("FRUITFLY", gmt)) {
      KEGG_species <- "dme"
    } else if (grep("RAT", gmt)) {
      KEGG_species <- "rno"
    }
    
    print(str(geneList))
    print(KEGGID)
    print(KEGG_species)
    
    plot <- pathview::pathview(gene.data = geneList,
                               pathway.id = KEGGID,
                               species = KEGG_species,
                               limit = list(gene = max(abs(geneList)), cpd = 1),
                               gene.idtype = "SYMBOL",
                               low = list(gene = "royalblue"),
                               mid = list(gene = "lightgrey"),
                               high = list(gene = "red"))

  # DOT PLOT
  } else if (plottype == "dot") {
    plot <- enrichplot::dotplot(enriched, 
                                showCategory = dotplot_categories, 
                                font.size = 12) +
      ggtitle(paste0(contrast, " ", dotplot_title))
    
  # CNET PLOT
  } else if (plottype == "cnet"){
    plot <- enrichplot::cnetplot(enriched, 
                                 categorySize = "pvalue", # pvalue or geneNum
                                 color.params = list(foldChange = geneList, edge = TRUE, category = "grey"), 
                                 node_label = cnetplot_label, # category, gene, all, or none
                                 showCategory = cnetplot_categories,
                                 cex.params = list(category_label = 1, gene_label = 0.7),
                                 circular = FALSE,
                                 layout = cnetplot_layout) +
      ggtitle(paste0(contrast, " ", cnet_title))
   
  # HEATMAP
  } else if (plottype == "heat"){
    colNames <- unique(names(geneList))
    
    top_enriched = enriched@result %>%
      as.data.frame() %>%
      tibble::remove_rownames() %>%
      dplyr::select(Description, p.adjust)
    
    if (length(top_enriched$Description) > 50){
      rowNames <- top_enriched$Description[1:50]
    } else {
      rowNames <- top_enriched$Description
    }
    
    heatmapDF <- data.frame(matrix(ncol = length(colNames), nrow = length(rowNames)))
    colnames(heatmapDF) <- colNames
    rownames(heatmapDF) <- rowNames
    
    message("GENERATING HEATMAP DATAFRAME:")
    progress <- utils::txtProgressBar(min = 0, max = nrow(heatmapDF), style = 3)
    for (row in 1:nrow(heatmapDF)){
      for (col in 1:ncol(heatmapDF)){
        pathway <- rownames(heatmapDF)[row]
        gene <- colnames(heatmapDF)[col]
        
        if (gene %in% enriched@geneSets[[pathway]]){
          heatmapDF[row, col] <- geneList[[gene]]
        }
      }
      utils::setTxtProgressBar(progress, row)
    }
    close(progress)
    
    heatmapDF[is.na(heatmapDF)] <- 0
    heatmapDF <- heatmapDF[,colSums(heatmapDF != 0) > 0]
    
    heatmapDF <- safe_scale(heatmapDF) # Z-score across rows
    heatmapDF[heatmapDF < -2] <- -2
    heatmapDF[heatmapDF > 2] <- 2
    
    message("INITIALIZING HEATMAP PLOTLY GENERATION")
    plot <- heatmaply::heatmaply(heatmapDF,
                                 scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(low = "royalblue", 
                                                                                         high = "red", 
                                                                                         midpoint = 0, 
                                                                                         limits = c(-max(abs(heatmapDF)), max(abs(heatmapDF)))),
                                 show_dendrogram = c(FALSE, FALSE), 
                                 showticklabels = c(FALSE, TRUE), 
                                 xlab = "Genes/IDs",
                                 ylab = "Pathways",
                                 main = paste(contrast, "Enrichment Heatmap", sep = " "),
                                 height = 1000,
                                 fontsize_row = 7)
    message("-- HEATMAP PLOTLY GENERATED")
  
  # EMAP
  } else if (plottype == "emap"){
    plot <- enrichplot::emapplot(enriched_pairwise,
                                 cex.params = list(category_label = emap_category_label),
                                 showCategory = emap_categories,
                                 repel = TRUE) +
      ggtitle(paste0(contrast, " ", emap_title))
    
  # TREE DIAGRAM
  } else if (plottype == "tree"){
    suppressMessages({
      plot <- enrichplot::treeplot(enriched_pairwise,
                                   showCategory = tree_categories,
                                   cluster.params = list(n = tree_clusters)) +
        ggtitle(paste0(contrast, " ", treeplot_title))
    })
    
  # UPSET PLOT
  } else if (plottype == "upset"){
    plot <- enrichplot::upsetplot(enriched, 
                                  n = upset_categories) +
      ggtitle(paste0(contrast, " ", upsetplot_title))
    
  } else if (plottype == "gseamulti"){
    # must be GSEA
    plot <- enrichplot::gseaplot2(enriched, 
                                  geneSetID = 1:5, 
                                  base_size = 11, 
                                  rel_heights = c(2.0, 0.5, 0.5))
    
  } else if (plottype == "gseasingle"){
    # must be GSEA
    for (i in 1:5){
      print(enrichplot::gseaplot2(enriched, 
                                  geneSetID = i, 
                                  title = enriched$Description[i]))
    }
  }
  
  # rm(enriched_pairwise)
  return(plot)
}

makeCytoscapeInput <- function(enrichmentResult){
  
  df <- data.frame(Term = enrichmentResult@result$ID,
                   Description = enrichmentResult@result$Description,
                   p.Val = enrichmentResult@result$pvalue,
                   FDR = enrichmentResult@result$qvalue,
                   Phenotype = sign(enrichmentResult@result$NES),
                   Genes = stringr::str_replace_all(enrichmentResult@result$core_enrichment, "/", ", "),
                   NES = enrichmentResult@result$NES,
                   ES = enrichmentResult@result$enrichmentScore,
                   Gene_Hits = lengths(strsplit(enrichmentResult@result$core_enrichment, "/")),
                   Gene_Total = enrichmentResult@result$setSize)
  
  return(df)
}



